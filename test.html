<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>부품 선택 → 쉼표 데이터 생성기 (일련번호/그룹태그/안정화)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
    .custom-scroll::-webkit-scrollbar { height: 8px; width: 8px; }
    .custom-scroll::-webkit-scrollbar-thumb { background: #3f3f46; border-radius: 9999px; }
    .custom-scroll::-webkit-scrollbar-track { background: #18181b; }
    .dropzone { border: 2px dashed #3f3f46; border-radius: 16px; }
    .dropzone.dragover { background: rgba(99,102,241,0.08); border-color: #6366f1; }
    .panel { border: 1px solid #262626; border-radius: 16px; background: #0b0b0c; }
    .btn { border-radius: 12px; padding: 8px 12px; }
    .seg { border-radius: 9999px; overflow: hidden; border: 1px solid #3f3f46; }
    .seg > button { padding: 6px 12px; }
    .seg .active { background: #6366f1; }
    
    /* 복사 성공 애니메이션 */
    .copy-success {
      background-color: #10b981 !important;
      transition: all 0.3s ease;
    }
    
    /* 검색 하이라이트 */
    .highlight {
      background-color: #fbbf24;
      color: #000;
      font-weight: bold;
      border-radius: 2px;
      padding: 0 2px;
    }
    
    /* 모바일 입력 최적화 */
    input[type="text"], input[type="number"] {
      font-size: 16px; /* iOS 확대 방지 */
    }
    textarea {
      font-size: 16px;
    }
  </style>
</head>
<body class="min-h-screen bg-neutral-950 text-neutral-100">
  <main class="max-w-5xl mx-auto py-6 px-4">
    <!-- 업로드/초기화 -->
    <section class="grid grid-cols-1 gap-3 mb-4">
      <div class="flex items-center gap-3 flex-wrap">
        <label class="rounded-2xl px-3 py-2 bg-neutral-800 hover:bg-neutral-700 border border-neutral-700 cursor-pointer select-none">
          파일 업로드
          <input id="file-input" type="file" accept=".xlsx,.xls" class="hidden" />
        </label>
        <button id="reset-btn" class="rounded-2xl px-3 py-2 bg-neutral-900 hover:bg-neutral-800 border border-neutral-700">
          데이터 초기화
        </button>
        <span id="file-info" class="text-xs text-neutral-400">엑셀(.xlsx, .xls) 파일을 업로드하세요.</span>
      </div>

      <!-- 드래그&드롭 -->
      <div id="dropzone" class="dropzone px-4 py-6 text-sm text-neutral-400">
        파일을 이 영역으로 드래그&드롭하거나, 상단의 파일 업로드 버튼을 사용하세요.
      </div>

      <!-- 기기(일련번호) 관리 -->
      <div class="panel p-4">
        <div class="flex items-center justify-between gap-3 flex-wrap">
          <div class="flex items-center gap-2">
            <h3 class="font-semibold">기기(일련번호) 관리</h3>
          </div>
          <div class="flex items-center gap-3">
            <div class="flex items-center gap-2">
              <span class="text-xs text-neutral-400">활성 기기: </span>
              <span id="active-device-label" class="text-xs text-indigo-300">없음</span>
            </div>
            <button id="delete-all-devices-btn"
                    class="btn bg-red-700 hover:bg-red-600 border border-red-600"
                    title="등록된 모든 기기를 삭제합니다. 되돌릴 수 없습니다.">
              등록된 기기 전체 삭제
            </button>
          </div>
        </div>

        <div class="mt-3 flex items-center gap-2 flex-wrap">
          <input id="device-input" type="text" 
                 class="rounded-xl px-3 py-2 bg-neutral-900 border border-neutral-700 w-64"
                 placeholder="일련번호(예: 609024, 628564)" 
                 inputmode="numeric" />
          <button id="device-add-btn" class="btn bg-neutral-800 hover:bg-neutral-700 border border-neutral-700">추가</button>
          <span class="text-xs text-neutral-500">쉼표/공백으로 여러 개 입력 가능. 끝의 마침표/쉼표는 자동 제거됩니다.</span>
        </div>

        <div id="device-chips" class="flex flex-wrap gap-2 mt-2"></div>

        <div class="mt-3 flex items-center gap-2 flex-wrap">
          <button id="copy-all-log-btn" class="btn bg-indigo-600 hover:bg-indigo-500">
            <span id="copy-all-log-btn-text">전체 로그 복사</span>
          </button>
          <button id="xlsx-all-btn" class="btn bg-orange-600 hover:bg-orange-500">
            <span id="xlsx-all-btn-text">전체 기기 XLSX 출력</span>
          </button>
          <button id="share-xlsx-btn" class="btn bg-yellow-600 hover:bg-yellow-500">
            <span id="share-xlsx-btn-text">XLSX 공유</span>
          </button>
        </div>

        <div class="mt-3 flex items-center gap-3">
          <span class="text-sm text-neutral-300">부품 사용 상태</span>
          <div class="seg inline-flex">
            <button id="usage-used" class="text-sm">부품 사용</button>
            <button id="usage-unused" class="text-sm" title="선택된 부품이 있으면 비활성화됩니다">장력조정</button>
          </div>
        </div>
      </div>

      <!-- 매핑 패널(수동 지정) -->
      <div id="mapping-panel" class="panel p-4 hidden">
        <div class="flex items-center justify-between">
          <h3 class="font-semibold">열 매핑 설정</h3>
          <span id="mapping-hint" class="text-xs text-neutral-400"></span>
        </div>
        <div class="grid grid-cols-1 md:grid-cols-3 gap-3 mt-3">
          <div>
            <label class="text-sm text-neutral-300">태그 열</label>
            <select id="map-tag-col" class="w-full mt-1 rounded-xl px-3 py-2 bg-neutral-900 border border-neutral-700"></select>
          </div>
          <div>
            <label class="text-sm text-neutral-300">부품명 열</label>
            <select id="map-name-col" class="w-full mt-1 rounded-xl px-3 py-2 bg-neutral-900 border border-neutral-700"></select>
          </div>
          <div class="flex items-end">
            <label class="inline-flex items-center gap-2 mt-6">
              <input id="map-has-header" type="checkbox" class="h-5 w-5 accent-indigo-500" />
              <span class="text-sm">첫 행은 헤더</span>
            </label>
          </div>
        </div>
        <div class="mt-3">
          <div class="text-sm text-neutral-400 mb-1">미리보기(최대 10행)</div>
          <div id="map-preview" class="text-sm bg-neutral-900 border border-neutral-800 rounded-xl p-3 max-h-40 overflow-auto"></div>
        </div>
        <div class="flex items-center gap-2 mt-3">
          <button id="map-apply" class="rounded-2xl px-4 py-2 bg-indigo-600 hover:bg-indigo-500">적용하기</button>
          <button id="map-cancel" class="rounded-2xl px-4 py-2 bg-neutral-800 hover:bg-neutral-700 border border-neutral-700">취소</button>
        </div>
      </div>

      <div id="category-bar" class="flex items-center gap-2 overflow-x-auto custom-scroll mt-2"></div>
      <div id="status" class="text-xs text-neutral-400"></div>
    </section>

    <section class="grid grid-cols-1 md:grid-cols-2 gap-6">
      <!-- 좌: 리스트 -->
      <div class="bg-neutral-900 border border-neutral-800 rounded-2xl p-3 md:p-4 shadow-lg">
        <div class="flex items-center justify-between mb-3">
          <h2 class="text-lg font-semibold">
            부품 리스트 <span id="count" class="text-neutral-400"></span>
          </h2>
          <button id="clear-btn" class="btn bg-neutral-800 hover:bg-neutral-700 border border-neutral-700">
            모두 지우기
          </button>
        </div>
        <div class="mb-3">
          <input id="search" type="text" 
                 placeholder="부품 검색... (초성 검색 가능: ㅂㄹㅌ → 볼트)"
                 class="w-full rounded-2xl px-4 py-2 bg-neutral-900 border border-neutral-800 focus:outline-none focus:ring-2 focus:ring-indigo-500" />
          <div id="search-info" class="text-xs text-neutral-500 mt-1"></div>
        </div>
        <div id="list" class="max-h-[420px] overflow-auto pr-1 custom-scroll"></div>
      </div>

      <!-- 우: 선택/출력(메모 대체) -->
      <div class="bg-neutral-900 border border-neutral-800 rounded-2xl p-3 md:p-4 shadow-lg flex flex-col">
        <div class="flex items-center justify-between mb-3">
          <h2 class="text-lg font-semibold">선택된 항목(현재 기기 메모)</h2>
          <span id="active-device-mini" class="text-xs text-neutral-400"></span>
        </div>
        <div id="selected-chips" class="flex flex-wrap gap-2 mb-4 min-h-[42px]"></div>
        <div>
          <textarea id="output" readonly 
                    class="w-full h-32 mt-1 rounded-xl px-3 py-2 bg-black/60 border border-neutral-800 font-mono text-sm focus:outline-none"
                    placeholder="선택된 부품들이 여기에 표시됩니다..."></textarea>
          <div class="flex items-center gap-2 mt-2 flex-wrap">
            <button id="copy-btn" class="btn bg-indigo-600 hover:bg-indigo-500 disabled:opacity-50 disabled:cursor-not-allowed">
              <span id="copy-btn-text">복사하기</span>
            </button>
          </div>
          <p class="mt-2 text-xs text-neutral-500">
            참고: 메모(현재 기기 출력)는 내부 공백이 제거됩니다. "장력조정" 선택 시 메모에는 "장력조정"이 표시됩니다.
          </p>
        </div>
      </div>
    </section>
  </main>

  <script>
    // ===== 초성 검색 유틸리티 (개선된 버전) =====
    const CHOSUNG = ['ㄱ','ㄲ','ㄴ','ㄷ','ㄸ','ㄹ','ㅁ','ㅂ','ㅃ','ㅅ','ㅆ','ㅇ','ㅈ','ㅉ','ㅊ','ㅋ','ㅌ','ㅍ','ㅎ'];
    
    function getChosung(str) {
      return str.split('').map(char => {
        const code = char.charCodeAt(0);
        if (code >= 44032 && code <= 55203) { // 한글 범위
          const base = code - 44032;
          const choIdx = Math.floor(base / 588);
          return CHOSUNG[choIdx];
        }
        return char;
      }).join('');
    }
    
    // 공백이 있는 부품명의 초성 검색 개선
    function matchesChosung(text, query) {
      // 공백 제거한 텍스트의 초성
      const textChosungNoSpace = getChosung(text.replace(/\s+/g, ''));
      // 원본 텍스트의 초성
      const textChosung = getChosung(text);
      
      // 공백 제거 쿼리와 원본 쿼리 모두 확인
      const queryNoSpace = query.replace(/\s+/g, '');
      
      return textChosungNoSpace.includes(queryNoSpace) || 
             textChosung.includes(query) ||
             textChosungNoSpace.includes(query) ||
             textChosung.includes(queryNoSpace);
    }

    // ===== 검색 하이라이팅 =====
    function highlightText(text, query) {
      if (!query.trim()) return text;
      
      const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
      return text.replace(regex, '<span class="highlight">$1</span>');
    }

    function getCurrentTimestamp() {
      const now = new Date();
      const year = now.getFullYear();
      const month = String(now.getMonth() + 1).padStart(2, '0');
      const day = String(now.getDate()).padStart(2, '0');
      const hour = String(now.getHours()).padStart(2, '0');
      const min = String(now.getMinutes()).padStart(2, '0');
      const sec = String(now.getSeconds()).padStart(2, '0');
      
      return `${year}-${month}-${day}_${hour}-${min}-${sec}`;
    }

    // ===== 기기별 메모 생성 (현재 기기 메모 기능처럼) =====
    function generateDeviceMemo(device) {
      if (device.used === false) {
        return "장력조정";
      }

      const entries = Object.entries(device.selected || {}).filter(([,q]) => Number(q) > 0);
      if (!entries.length) return "";

      const tokens = [];
      entries.forEach(([pid, qty]) => {
        const part = parts.find(x => x.id === pid);
        if (!part) return;
        const name = (part.name || "").replace(/\s+/g, ""); // 공백 제거
        const n = Number(qty) || 0;
        tokens.push(n <= 1 ? name : `${name}x${n}`);
      });
      
      return tokens.length ? `${tokens.join(",")} 교체` : "";
    }

    // ===== XLSX 전체 기기 출력 기능 (개선된 버전) =====
    function generateAllDevicesXLSX() {
      if (!Array.isArray(devices) || devices.length === 0) {
        alert('출력할 기기가 없습니다.');
        return { success: false };
      }

      const wsData = [];
      
      // 헤더 추가 (마지막 공란을 '메모'로 변경)
      wsData.push(['기기번호', '부품명(필수입력)', '', '수량', '', '', '메모']);
      
      // 기기별로 정렬
      const sorted = [...devices].sort((a,b) => {
        const na = Number(a.id), nb = Number(b.id);
        if (!Number.isNaN(na) && !Number.isNaN(nb)) return na - nb;
        return String(a.id).localeCompare(String(b.id), 'ko');
      });

      sorted.forEach(device => {
        if (!device) return;
        
        // 장력조정인 경우
        if (device.used === false) {
          wsData.push([device.id, '장력조정', '', '', '', '', '장력조정']);
          return;
        }

        // 부품 사용인 경우
        const entries = Object.entries(device.selected || {}).filter(([,q]) => Number(q) > 0);
        if (!entries.length) return;

        let isFirstPart = true;
        entries.forEach(([pid, qty]) => {
          const part = parts.find(x => x.id === pid);
          if (!part) return;
          
          // 부품명에 태그 추가 (예: [pl.s]나사)
          const partNameWithTag = part.tags.length > 0 
            ? `[${part.tags[0]}]${part.name}` 
            : part.name;
          
          // 첫 번째 부품에만 기기번호 표시, 나머지는 빈칸
          const deviceNumber = isFirstPart ? device.id : '';
          
          wsData.push([
            deviceNumber,
            partNameWithTag,
            '', // 공란
            Number(qty),
            '', // 공란
            '', // 공란
            ''  // 메모는 마지막 행에만 추가
          ]);
          
          isFirstPart = false;
        });

        // 마지막 행에 메모 추가 (부품명들 + "교체")
        if (entries.length > 0) {
          const memo = generateDeviceMemo(device);
          if (memo && wsData.length > 0) {
            wsData[wsData.length - 1][6] = memo; // 마지막 행의 메모 컬럼에 추가
          }
        }
      });

      if (wsData.length <= 1) {
        alert('출력할 데이터가 없습니다.');
        return { success: false };
      }

      // 워크시트 생성
      const ws = XLSX.utils.aoa_to_sheet(wsData);
      
      // 컬럼 너비 설정
      ws['!cols'] = [
        { width: 10 }, // 기기번호
        { width: 25 }, // 부품명(필수입력)
        { width: 5 },  // 공란
        { width: 8 },  // 수량
        { width: 5 },  // 공란
        { width: 5 },  // 공란
        { width: 20 }  // 메모
      ];

      // 워크북 생성
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, '전체기기부품사용내역');

      // 파일명 생성 (분초 포함)
      const timestamp = getCurrentTimestamp();
      const filename = `all_devices_${timestamp}.xlsx`;

      // 파일 다운로드
      XLSX.writeFile(wb, filename);
      
      return { success: true, workbook: wb, filename };
    }

    // ===== XLSX 공유 기능 =====
    async function shareXLSX() {
      if (!navigator.share) {
        alert('이 브라우저는 공유 기능을 지원하지 않습니다.');
        return false;
      }

      const result = generateAllDevicesXLSX();
      if (!result.success) return false;

      try {
        // 워크북을 Blob으로 변환
        const wbout = XLSX.write(result.workbook, { bookType: 'xlsx', type: 'array' });
        const blob = new Blob([wbout], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
        const file = new File([blob], result.filename, { 
          type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' 
        });
        
        await navigator.share({
          title: '전체 기기 부품 사용 내역',
          text: '전체 기기의 부품 사용 내역입니다.',
          files: [file]
        });
        return true;
      } catch (error) {
        console.error('XLSX 공유 실패:', error);
        alert('XLSX 공유에 실패했습니다.');
        return false;
      }
    }

    // ===== 복사 버튼 성공 표시 =====
    function showCopySuccess(button, textElement) {
      const originalText = textElement.textContent;
      const originalClass = button.className;
      
      // 성공 표시
      textElement.textContent = "✅ 복사됨!";
      button.classList.add("copy-success");
      
      // 2초 후 원래대로
      setTimeout(() => {
        textElement.textContent = originalText;
        button.className = originalClass;
      }, 2000);
    }

    function showXLSXSuccess(button, textElement) {
      const originalText = textElement.textContent;
      const originalClass = button.className;
      
      textElement.textContent = "✅ XLSX 생성됨!";
      button.classList.add("copy-success");
      
      setTimeout(() => {
        textElement.textContent = originalText;
        button.className = originalClass;
      }, 2000);
    }

    function showShareXLSXSuccess(button, textElement) {
      const originalText = textElement.textContent;
      const originalClass = button.className;
      
      textElement.textContent = "✅ 공유됨!";
      button.classList.add("copy-success");
      
      setTimeout(() => {
        textElement.textContent = originalText;
        button.className = originalClass;
      }, 2000);
    }

    // ===== XLSX 로더 보강: 메인 CDN 실패 시 대체 =====
    async function ensureXLSX() {
      if (window.XLSX) return true;
      return new Promise((resolve) => {
        const s = document.createElement('script');
        s.src = 'https://unpkg.com/xlsx@0.18.5/dist/xlsx.full.min.js';
        s.onload = () => resolve(!!window.XLSX);
        s.onerror = () => resolve(false);
        document.head.appendChild(s);
      });
    }

    // ===== 상수 & 유틸 =====
    const STORAGE_KEY = 'parts-selector.v3';
    const COMMON_TAG = "공용";
    const NAME_HEADERS = ["name","part","partname","item","품명","이름","부품","부품명","품목","제품명"];
    const TAG_HEADERS  = ["category","cat","tag","tags","카테고리","분류","태그"];
    const TAG_GROUP_ALIASES = { 'pls': '킥보드', 'pl': '킥보드', 'b2': '자전거', 'b4': '자전거', '공용': '공용' };

    const $ = (sel) => document.querySelector(sel);
    const normKR = (s) => (s || "").normalize("NFKD").toLowerCase().replace(/\s+/g, "");
    const toTagKey = (t) => String(t || '').trim().toLowerCase().replace(/\./g, '');
    const mapTagToGroup = (tag) => TAG_GROUP_ALIASES[toTagKey(tag)] || tag;

    const setStatus = (msg, isError=false) => {
      const el = $("#status");
      el.textContent = msg || "";
      el.className = "text-xs " + (isError ? "text-red-400" : "text-neutral-400");
    };
    const colLetter = (i) => { let s = ""; i = Number(i); while (i >= 0) { s = String.fromCharCode((i % 26) + 65) + s; i = Math.floor(i / 26) - 1; } return s; };

    function stripBracketPrefix(raw) {
      const str = String(raw ?? "").trim();
      const m = str.match(/^\s*\[[^\]]+\]\s*(.*)$/);
      return m ? (m[1] || "").trim() : str;
    }
    function parseBracketed(raw) {
      const str = String(raw ?? "").trim();
      const m = str.match(/^\s*\[([^\]]+)\]\s*(.*)$/);
      if (m) {
        const category = (m[1] || "").trim() || "기타";
        const name = stripBracketPrefix(m[2] || "");
        return { category, name };
      }
      return null;
    }
    function splitTags(catString) {
      const raw = String(catString ?? "").trim();
      if (!raw) return ["기타"];
      const arr = raw.split("/").map(s => s.trim()).filter(Boolean);
      return Array.from(new Set(arr));
    }

    // ===== 상태 =====
    let parts = [];
    let selected = {};          
    let activeCategory = null;  
    let query = "";
    let lastFileName = "";
    let lastSheetName = "";
    let mapState = { tagIdx: 0, nameIdx: 1, hasHeader: true };

    let devices = [];
    let activeDeviceId = null;

    // ===== 로컬 스토리지 =====
    function saveState() {
      try {
        const payload = {
          v: 3,
          parts, selected, activeCategory, query,
          meta: { fileName: lastFileName, sheetName: lastSheetName, mapping: mapState },
          devices, activeDeviceId
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
      } catch (e) { console.warn("상태 저장 실패:", e); }
    }

    function loadState() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return false;
        const data = JSON.parse(raw);
        if (!data || !Array.isArray(data.parts)) return false;

        parts = data.parts.map(p => {
          const tags = Array.isArray(p.tags) ? p.tags : ["기타"];
          const groupTags = Array.isArray(p.groupTags) && p.groupTags.length ? p.groupTags : tags.map(mapTagToGroup);
          return {
            id: p.id || `${(p.name||"")}||${tags.slice().sort().join('/')}`,
            tags,
            groupTags,
            name: stripBracketPrefix(p.name || ""),
            normName: p.normName || normKR(p.name || "")
          };
        });
        selected = data.selected || {};
        query = data.query || "";
        activeCategory = data.activeCategory || null;
        lastFileName = data.meta?.fileName || "";
        lastSheetName = data.meta?.sheetName || "";
        mapState = data.meta?.mapping || mapState;

        devices = Array.isArray(data.devices) ? data.devices.map(d => ({
          id: d.id,
          selected: d.selected || {},
          used: typeof d.used === 'boolean' ? d.used : true
        })) : [];
        activeDeviceId = data.activeDeviceId || null;

        if (activeDeviceId) {
          const dev = devices.find(x => x.id === activeDeviceId);
          if (dev) selected = { ...dev.selected };
        }
        return true;
      } catch (e) {
        console.warn("상태 로드 실패:", e);
        return false;
      }
    }

    function updateFileInfo(text) {
      const el = $("#file-info");
      if (el) el.textContent = text || "";
    }

    // ===== 태그/필터(그룹 기준) =====
    function buildCategories() {
      const set = new Set();
      parts.forEach(p => {
        const gs = Array.isArray(p.groupTags) ? p.groupTags : (Array.isArray(p.tags) ? p.tags.map(mapTagToGroup) : []);
        gs.forEach(g => set.add(g));
      });
      return Array.from(set);
    }

    // ===== 개선된 검색 필터 =====
    function getFiltered() {
      const qn = normKR(query);
      const isChosung = /^[ㄱ-ㅎ\s]+$/.test(query.trim());
      
      return parts.filter(p => {
        const gs = Array.isArray(p.groupTags) ? p.groupTags : (Array.isArray(p.tags) ? p.tags.map(mapTagToGroup) : []);
        const catOk = !activeCategory || gs.includes(activeCategory) || gs.includes(COMMON_TAG);
        
        let txtOk = true;
        if (query.trim()) {
          if (isChosung) {
            txtOk = matchesChosung(p.name, query.trim());
          } else {
            txtOk = p.normName.includes(qn);
          }
        }
        
        return catOk && txtOk;
      });
    }

    // ===== 기기(일련번호) 관리 =====
    function sanitizeDeviceId(raw) {
      const s = String(raw || '').trim();
      return s.replace(/[.,;]+$/g, '');
    }
    function ensureDevice(id) {
      id = sanitizeDeviceId(id);
      if (!id) return null;
      let d = devices.find(x => x.id === id);
      if (!d) {
        d = { id, selected: {}, used: true };
        devices.push(d);
      }
      return d;
    }
    function switchActiveDevice(id) {
      if (activeDeviceId) {
        const prev = devices.find(x => x.id === activeDeviceId);
        if (prev) prev.selected = { ...selected };
      }
      activeDeviceId = id;
      const cur = devices.find(x => x.id === activeDeviceId);
      selected = cur ? { ...cur.selected } : {};
      saveState();
      renderDevices();
      renderList();
      renderSelectedChips();
      renderOutput();
    }
    function removeDevice(id) {
      const idx = devices.findIndex(x => x.id === id);
      if (idx >= 0) devices.splice(idx, 1);
      if (activeDeviceId === id) {
        activeDeviceId = null;
        selected = {};
      }
      saveState();
      renderDevices();
      renderList();
      renderSelectedChips();
      renderOutput();
    }
    function syncSelectedToActiveDevice() {
      if (!activeDeviceId) return;
      const cur = devices.find(x => x.id === activeDeviceId);
      if (!cur) return;
      cur.selected = { ...selected };
      saveState();
      renderDevices();
    }

    function hasActiveSelection() {
      return Object.values(selected || {}).some(v => Number(v) > 0);
    }

    function updateUsageButtons() {
      const usedBtn = $("#usage-used");
      const unusedBtn = $("#usage-unused");
      const hasActive = !!activeDeviceId;
      const hasSel = hasActive && hasActiveSelection();

      usedBtn.disabled = !hasActive;
      unusedBtn.disabled = !hasActive || hasSel;

      [usedBtn, unusedBtn].forEach(b => {
        b.classList.toggle("opacity-50", b.disabled);
        b.classList.toggle("cursor-not-allowed", b.disabled);
      });

      if (!hasActive) {
        usedBtn.title = "활성 기기를 먼저 선택하세요.";
        unusedBtn.title = "활성 기기를 먼저 선택하세요.";
      } else if (hasSel) {
        usedBtn.title = "";
        unusedBtn.title = "선택된 부품이 있어 장력조정으로 전환할 수 없습니다.";
      } else {
        usedBtn.title = "";
        unusedBtn.title = "";
      }
    }

    function renderDevices() {
      const chips = $("#device-chips");
      chips.innerHTML = "";
      const label = $("#active-device-label");
      const mini = $("#active-device-mini");
      label.textContent = activeDeviceId || "없음";
      mini.textContent = activeDeviceId ? `기기: ${activeDeviceId}` : "";

      if (!devices.length) {
        const span = document.createElement("span");
        span.className = "text-neutral-500 text-sm";
        span.textContent = "일련번호를 추가하세요.";
        chips.appendChild(span);
      } else {
        const sorted = [...devices].sort((a,b)=>{
          const na = Number(a.id), nb = Number(b.id);
          if (!Number.isNaN(na) && !Number.isNaN(nb)) return na - nb;
          return String(a.id).localeCompare(String(b.id), 'ko');
        });
        sorted.forEach(d=>{
          const count = Object.values(d.selected || {}).reduce((s,v)=> s + (Number(v)||0), 0);
          const isActive = activeDeviceId === d.id;
          const wrap = document.createElement("div");
          wrap.className = `flex items-center gap-1 rounded-full px-2 py-1 border ${isActive ? "bg-indigo-600 border-indigo-500" : "bg-neutral-900 border-neutral-700"}`;

          const btn = document.createElement("button");
          btn.className = "px-2";
          btn.textContent = count ? `${d.id}(${count})` : d.id;
          btn.title = d.used ? "부품 사용" : "장력조정";
          btn.addEventListener("click", ()=> switchActiveDevice(d.id));

          const del = document.createElement("button");
          del.className = "rounded-full px-2 hover:bg-neutral-800";
          del.textContent = "✕";
          del.title = "삭제";
          del.addEventListener("click", ()=> removeDevice(d.id));

          wrap.append(btn, del);
          chips.appendChild(wrap);
        });
      }

      const usedBtn = $("#usage-used");
      const unusedBtn = $("#usage-unused");
      usedBtn.classList.remove("active");
      unusedBtn.classList.remove("active");
      if (activeDeviceId) {
        const cur = devices.find(x => x.id === activeDeviceId);
        if (cur && cur.used) usedBtn.classList.add("active");
        else unusedBtn.classList.add("active");
      }
      updateUsageButtons();
    }

    // ===== 렌더링(리스트/선택/출력) =====
    function renderCategoryBar() {
      const bar = $("#category-bar");
      bar.innerHTML = "";
      if (parts.length === 0) return;

      const cats = buildCategories();
      cats.forEach(cat => {
        const isActive = activeCategory === cat;
        const btn = document.createElement("button");
        btn.textContent = cat;
        btn.className = `rounded-full px-3 py-1 border select-none ${isActive ? "bg-indigo-600 border-indigo-500" : "bg-neutral-900 border-neutral-700 hover:bg-neutral-800"}`;
        btn.addEventListener("click", () => {
          activeCategory = (activeCategory === cat) ? null : cat;
          saveState();
          renderCategoryBar();
          renderList();
        });
        bar.appendChild(btn);
      });
    }

    function liBaseClass(checked) {
      return `flex items-center gap-3 bg-neutral-950 border border-neutral-800 rounded-xl p-2 ${checked ? "ring-1 ring-indigo-500/40" : ""}`;
    }

    function toggleSelectionById(id, li, cb) {
      if (selected[id] && selected[id] > 0) {
        delete selected[id];
        if (li) li.className = liBaseClass(false);
        if (cb) cb.checked = false;
      } else {
        selected[id] = 1;
        if (li) li.className = liBaseClass(true);
        if (cb) cb.checked = true;
      }
      renderSelectedChips();
      renderOutput();
      syncSelectedToActiveDevice();
    }

    function renderList() {
      const container = $("#list");
      container.innerHTML = "";

      if (parts.length === 0) {
        const empty = document.createElement("div");
        empty.className = "text-neutral-500 text-sm py-8 text-center";
        empty.textContent = "엑셀 파일을 업로드하세요.";
        container.appendChild(empty);
        $("#count").textContent = "(0)";
        $("#search-info").textContent = "";
        renderSelectedChips();
        renderOutput();
        return;
      }
